// Generated by IcedCoffeeScript 1.7.1-f

/*
 * requires moduleHelper.js
 * requires JQuery 2.1.1
 * requires b64.js
 */

(function() {
  var iced, __iced_k, __iced_k_noop,
    __slice = [].slice;

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        ++this.count;
        return (function(_this) {
          return function() {
            var inner_params, _ref;
            inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (defer_params != null) {
              if ((_ref = defer_params.assign_fn) != null) {
                _ref.apply(null, inner_params);
              }
            }
            return _this._fulfill();
          };
        })(this);
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  this.module("i5", function() {
    return this.module("las2peer", function() {
      return this.module("jsAPI", function() {

        /*
          Enum for various supportet login types.
          For now only BASIC Auth is supported.
         */
        var LoginTypes;
        LoginTypes = {
          NONE: 0,
          HTTP_BASIC: 1
        };
        this.LoginTypes = LoginTypes;

        /*
          Login class manages login related tasks, e.g. base64 encoding etc.
         */
        this.Login = (function() {
          function Login(loginType) {
            this.loginType = loginType;
          }

          Login.prototype.setUserAndPassword = function(user, password) {
            this.user = user;
            this.password = password;
          };

          Login.prototype.getBasicAuthLogin = function() {
            return B64.encode(this.user + ":" + this.password);
          };

          return Login;

        })();

        /*
          Simple class for request objects.
         */
        this.Request = (function() {
          function Request(method, uri, content, callback, errorCallback) {
            this.method = method;
            this.uri = uri;
            this.content = content;
            this.callback = callback;
            this.errorCallback = errorCallback;
            if (errorCallback == null) {
              errorCallback = function() {};
            }
          }

          return Request;

        })();

        /*
          Provides an easy way to send ajax requests.
         */
        return this.RequestSender = (function() {

          /*
            Constructor takes a uri to the service and a login object to manage logins automatically.
            Additionally an ajax object can be given as a parameter to override default some values.
           */
          function RequestSender(baseURI, login, newBaseAjaxObj) {
            var basic;
            this.baseURI = baseURI;
            basic = LoginTypes;
            this.baseAjaxObj = {
              contentType: "text/plain",
              crossDomain: true,
              beforeSend: function(xhr) {
                if (login.loginType === LoginTypes.HTTP_BASIC) {
                  return xhr.setRequestHeader("Authorization", "Basic " + login.getBasicAuthLogin());
                }
              }
            };
            if (newBaseAjaxObj != null) {
              $.extend(true, this.baseAjaxObj, newBaseAjaxObj);
            }
          }


          /*
            Sends a request to the given uri with the given method and content data.
            Two callbacks can be passed (the first for a successfull response, the second for error notification).
            The errorCallback is optional.
           */

          RequestSender.prototype.sendRequest = function(method, URI, content, callback, errorCallback) {
            var newAjax, requestURI;
            requestURI = encodeURI(this.baseURI + "/" + URI);
            newAjax = {
              url: requestURI,
              method: method.toUpperCase(),
              data: content,
              error: function(xhr, errorType, error) {
                var errorText;
                errorText = error;
                if ((xhr.responseText != null) && xhr.responseText.trim().length > 0) {
                  errorText = xhr.responseText;
                }
                if (xhr.status === 0) {
                  errorText = "WebConnector does not respond";
                }
                if (errorCallback != null) {
                  return errorCallback(xhr.status + " " + method + " " + requestURI + "\n" + errorText);
                }
              },
              success: function(data, status, xhr) {
                return callback(xhr.responseText);
              }
            };
            $.extend(true, newAjax, this.baseAjaxObj);
            return $.ajax(newAjax);
          };


          /*
            This is a helper method for iced coffescript, which only supports one callback for deferrals.
            It combines both callbacks of sendRequest into one
           */

          RequestSender.prototype.sendRequestCombined = function(method, URI, content, callback) {
            var combined;
            combined = {};
            return this.sendRequest(method, URI, content, function(data) {
              combined.success = true;
              combined.data = data;
              return callback(combined);
            }, function(error) {
              combined.success = false;
              combined.data = error;
              return callback(combined);
            });
          };


          /*
            Wrapper method to use sendRequest with a Request object.
           */

          RequestSender.prototype.sendRequestObj = function(requestObj) {
            return this.sendRequest(requestObj.method, requestObj.uri, requestObj.content, requestObj.callback, requestObj.errorCallback);
          };


          /*
            Sends requests in a given array synchronously (order is maintained, usefull if operations depend on each other's completion).
            When all requests are finished callback is called.
           */

          RequestSender.prototype.sendRequestsSync = function(requestObjArray, callback) {
            var combined, i, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
            __iced_k = __iced_k_noop;
            ___iced_passed_deferral = iced.findDeferral(arguments);
            (function(_this) {
              return (function(__iced_k) {
                var _i, _len, _ref, _results, _while;
                _ref = requestObjArray;
                _len = _ref.length;
                i = 0;
                _results = [];
                _while = function(__iced_k) {
                  var _break, _continue, _next;
                  _break = function() {
                    return __iced_k(_results);
                  };
                  _continue = function() {
                    return iced.trampoline(function() {
                      ++i;
                      return _while(__iced_k);
                    });
                  };
                  _next = function(__iced_next_arg) {
                    _results.push(__iced_next_arg);
                    return _continue();
                  };
                  if (!(i < _len)) {
                    return _break();
                  } else {
                    k = _ref[i];
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "C:\\Visual Studio 2013\\Projects\\Microblog\\JS\\ServiceAPI\\serviceAPI.iced",
                        funcname: "RequestSender.sendRequestsSync"
                      });
                      _this.sendRequestCombined(k.method, k.uri, k.content, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return combined = arguments[0];
                          };
                        })(),
                        lineno: 114
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      return _next(combined.success ? k.callback(combined.data) : k.errorCallback != null ? k.errorCallback(combined.data) : void 0);
                    });
                  }
                };
                _while(__iced_k);
              });
            })(this)((function(_this) {
              return function() {
                return callback();
              };
            })(this));
          };


          /*
            Sends requests in a given array asynchronously (order is arbitrary).
            When all requests are finished callback is called.
           */

          RequestSender.prototype.sendRequestsAsync = function(requestObjArray, callback) {
            var combined, i, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
            __iced_k = __iced_k_noop;
            ___iced_passed_deferral = iced.findDeferral(arguments);
            combined = [];
            (function(_this) {
              return (function(__iced_k) {
                var _i, _len;
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "C:\\Visual Studio 2013\\Projects\\Microblog\\JS\\ServiceAPI\\serviceAPI.iced",
                  funcname: "RequestSender.sendRequestsAsync"
                });
                for (i = _i = 0, _len = requestObjArray.length; _i < _len; i = ++_i) {
                  k = requestObjArray[i];
                  _this.sendRequestCombined(k.method, k.uri, k.content, __iced_deferrals.defer({
                    assign_fn: (function(__slot_1, __slot_2) {
                      return function() {
                        return __slot_1[__slot_2] = arguments[0];
                      };
                    })(combined, i),
                    lineno: 131
                  }));
                }
                __iced_deferrals._fulfill();
              });
            })(this)((function(_this) {
              return function() {
                var _i, _len;
                for (i = _i = 0, _len = combined.length; _i < _len; i = ++_i) {
                  k = combined[i];
                  if (k.success) {
                    requestObjArray[i].callback(k.data);
                  } else if (requestObjArray[i].errorCallback != null) {
                    requestObjArray[i].errorCallback(k.data);
                  }
                }
                return callback();
              };
            })(this));
          };

          return RequestSender;

        })();
      });
    });
  });

}).call(this);

//# sourceMappingURL=serviceAPI.js.map